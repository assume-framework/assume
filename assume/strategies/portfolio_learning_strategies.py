# SPDX-FileCopyrightText: ASSUME Developers
#
# SPDX-License-Identifier: AGPL-3.0-or-later

from assume.common.market_objects import MarketConfig, Orderbook, Product
from assume.strategies.portfolio_strategies import UnitOperatorStrategy


class PortfolioRLStrategy(UnitOperatorStrategy):
    """
    Reinforcement Learning Strategy that enables the agent to learn optimal bidding strategies for
    the portfolio of a units operator on an Energy-Only Market.

    The agent submits a discrete price curve of price, quantity pairs for 6 technology types (OCGT, CCGT,
    lignite, hard coal, nuclear, oil) according to their available capacity in the portfolio.
    This strategy utilizes a set of 52 observations to generate actions, which are then transformed into 
    market bids. The observation space for this strategy consists of 36 global observations and
    and 3 unique values for each technology type (i.e. 18 in total) in the portfolio. 
    
    Observations include the following components:

    - **Forecasted Residual Load**: Forecasted load over the foresight period, scaled by the maximum
      demand, indicating anticipated grid conditions.
    - **Forecasted Price**: Price forecast over the foresight period, scaled by the maximum bid price,
      providing a sense of expected market prices.
      For each technology:
        - **Total min capacity, Total max capacity and Avg marginal cost**: The last 3x6 elements of the 
        observation vector, representing the unique state of the portfolio. Here, `total min capacity`  and
        `total max capacity` are scaled by the total installed capacity of the technology for the units
        operator, while `average marginal cost` is scaled by the maximum bid price. 

    Actions are formulated as 2 values (price, quantity) for each technology. Prices and quantity are zero 
    if the technology is not in the portfolio of the units operator. Actions are denormalized from a range of [-1, 1] 
    to real bid prices in the `calculate_bids` method, then translate into unit-specific bids.

    Rewards are based on profit from transactions, minus operational and opportunity costs. Key components include:

    - **Profit**: Determined from the income generated by accepted bids, calculated as the product of
      accepted price, volume, and duration.
    - **Operational Costs**: Includes marginal costs and start-up costs when a unit transitions between
      on and off states.

    Attributes
    ----------
    foresight : int
        Number of time steps for which the agent forecasts market conditions. Defaults to 24.
    max_bid_price : float
        Maximum allowable bid price. Defaults to 100.
    min_bid_price : float
        Maximum allowable bid price. Defaults to  -100.
    max_demand : float
        Maximum demand capacity of the unit. Defaults to 10e3.
    device : str
        Device for computation, such as "cpu" or "cuda". Defaults to "cpu".
    float_type : str
        Data type for floating-point calculations, typically "float32". Defaults to "float32".
    learning_mode : bool
        Indicates whether the agent is in learning mode. Defaults to False.
    algorithm : str
        Name of the RL algorithm in use. Defaults to "matd3".
    actor_architecture_class : type[torch.nn.Module]
        Class of the neural network architecture used for the actor network. Defaults to MLPActor.
    actor : torch.nn.Module
        Actor network for determining actions.
    order_types : list[str]
        Types of market orders supported by the strategy. Defaults to ["SB"].
    action_noise : NormalActionNoise
        Noise model added to actions during learning to encourage exploration. Defaults to None.
    collect_initial_experience_mode : bool
        Whether the agent is collecting initial experience through exploration. Defaults to True.

    Args
    ----
    *args : Variable length argument list.
    **kwargs : Arbitrary keyword arguments.
    """

    def __init__(self, *args, **kwargs):

        obs_dim = kwargs.pop("obs_dim", 54) # 36 shared observations + 18 unique_observations  
        act_dim = kwargs.pop("act_dim", 12)
        unique_obs_dim = kwargs.pop("unique_obs_dim", 18) # min and max power 
        kwargs["unit_id"] = 'rl_operator'
        super().__init__(
            obs_dim=obs_dim,
            act_dim=act_dim,
            unique_obs_dim=unique_obs_dim,
            *args,
            **kwargs,
        )

        # 'foresight' represents the number of time steps into the future that we will consider
        # when constructing the observations. This value is fixed for each strategy, as the
        # neural network architecture is predefined, and the size of the observations must remain consistent.
        # If you wish to modify the foresight length, remember to also update the 'obs_dim' parameter above,
        # as the observation dimension depends on the foresight value.
        self.foresight = 12

        # define allowed order types
        self.technology_type = ["combined cycle gas turbine", "hard coal", "lignite", "nuclear", "oil", "open cycle gas turbine"]
        self.technology_dim = len(self.technology_type)
        self.order_types = kwargs.get("order_types", ["SB"])


    def calculate_bids(
        self,
        units_operator: "UnitsOperator",
        market_config: MarketConfig,
        product_tuples: list[Product],
        **kwargs,
    ) -> Orderbook:
        """
        Calculates bids based on the current observations and actions derived from the actor network.

        Args
        ----
            units_operator (UnitsOperator): The operator that bids on the market.
            market_config (MarketConfig): The configuration of the market.
            product_tuples (list[Product]): List of products with start and end times for bidding.
            **kwargs : Additional keyword arguments.

        Returns
        -------
        Orderbook
            Contains bid entries for each product, including start time, end time, price, and volume.

        Notes
        -----
        This method obtains actions as a tensor of quantities and bid prices for each technology, 
        denormalize them to reflect real bid prices and volumes, which are then converted into
        unit-specific bids by sorting the units of each technology type by their marginal cost, 
        and bidding their maximum available capacity at the bid price defined by the action
        tensor, until the total technology volume defined by the action tensor is satisfied.
        """

        start = product_tuples[0][0]
        end = product_tuples[0][1]

        # assign forecaster, outputs dict and technology_max_power dict to units_operator
        if not hasattr(units_operator, 'technology_max_power'):
            print("at least till here!")
            units_operator.init_portfolio_learning()
        
        # =============================================================================
        # 1. Get the Observations, which are the basis of the action decision
        # =============================================================================
        next_observation = self.create_observation(
            unit=units_operator,
            market_id=market_config.market_id,
            start=start,
            end=end,
        )

        # =============================================================================
        # 2. Get the Actions, based on the observations
        # =============================================================================
        actions, noise = self.get_actions(next_observation)
    
        # =============================================================================
        # 3. Transform Actions into bids
        # =============================================================================
        # actions are in the range [-1,1], we need to transform them into actual bids
        # we can use our domain knowledge to guide the bid formulation
        scaled_quantity = actions[:self.technology_dim].numpy()

        min_power = next_observation[-3* self.technology_dim : -2*self.technology_dim]
        max_power = next_observation[-2* self.technology_dim : -self.technology_dim]
        denormalize = lambda q, m, M: ((q + 1) / 2) * (M - m) + m
        bid_quantity = [denormalize(q, m, M) for q, m, M in zip(scaled_quantity, min_power, max_power)]
        
        scaled_prices = actions[self.technology_dim:].numpy()
        bid_prices = denormalize(scaled_prices, self.min_price, self.max_price)
        # bid_prices = actions[self.technology_dim:].numpy() * self.max_bid_price

        # actually formulate bids in orderbook format
        start_units = {tec: [] for tec in self.technology_type}
        bids = []
        
        for unit_id, unit in units_operator.units.items():
            min_mw, max_mw = unit.calculate_min_max_power(start,end)
            mc = unit.calculate_marginal_cost(start, max_mw)
            # unit tuples of ID, max available capacity, marginal cost
            start_units[unit_id.technology].append((unit_id, max_mw, mc))

        for tec, technology in enumerate(self.technology_type): 
            #do not bid anything if there is no unit of that specific technology type
            if len(start_units[technology]) == 0: 
                continue
            # sort unit tuples by by marginal cost
            technology_units = sorted(start_units[technology], key=lambda x: x[-1])  

            for unit_tuple in technology_units:
                # bid the maximum available capacity of units until bid_quantity is covered
                # or there are no further units
                if bid_quantity[tec] > 0:
                    bids.append({           
                    "start_time": start,
                    "end_time": end,
                    "only_hours": None,
                    "price": bid_prices[tec],
                    # min() for partial bid if avail capacity is greater than bid_quantity left
                    "volume": min(unit_tuple[1], bid_quantity[tec]),
                    "unit_id": unit_tuple[0],
                    "bid_id": f"{units_operator.id}_{unit_tuple[0]}", # units_operator.id_unit.id
                    "node": units_operator.units[unit_tuple[0]].node,
                    })
                    bid_quantity[tec] -= unit_tuple[1] 
                else:
                    break            

        # store results in unit outputs as lists to be written to the buffer for learning
        units_operator.outputs["rl_observations"].append(next_observation)
        units_operator.outputs["rl_actions"].append(actions)

        # store results in unit outputs as series to be written to the database by the unit operator
        units_operator.outputs["actions"].at[start] = actions
        units_operator.outputs["exploration_noise"].at[start] = noise

        return bids


    def get_actions(self, next_observation:th.Tensor) -> tuple[th.Tensor, th.Tensor]:
        """
        Compute actions based on the current observation.

        Args
        ----
        next_observation (torch.Tensor): The current observation, where the last element is assumed to be the marginal cost.

        Returns
        -------
        tuple of torch.Tensor
            A tuple containing: Actions to be taken (with or without noise). The noise component (if any), useful for diagnostics.
            The action to be taken represent 6 volumes and 6 prices in the range [-1, 1], each stands for one technology type.

        Notes
        -----
        During learning, exploratory noise is applied and already part of the curr_action unless in evaluation mode.
        In initial exploration mode, price actions are sampled around the marginal cost and quantity actions around the 
        max available capacity to explore its vicinity. We assume the final element of `next_observation` is the marginal cost.
        """

        # Get the base action and associated noise from the parent implementation
        curr_action, noise = super().get_actions(next_observation)

        if self.learning_mode and not self.evaluation_mode:
            if self.collect_initial_experience_mode:
                # Assumes last dimensions of the observation correspond to marginal costs
                marginal_costs = next_observation[
                    -self.technology_dim:
                ].detach()  # ensure no gradients flow through
                # Add marginal cost to the bid action directly for initial random exploration
                curr_action[self.technology_dim:] = curr_action[self.technology_dim:] + marginal_costs 
                
                max_capacity = next_observation[
                    -2*self.technology_dim : - self.technology_dim
                ].detach() # ensure no gradients flow through
                curr_action[:self.technology_dim] = curr_action[:self.technology_dim] + max_capacity 
                # Add max capacity to the price action directly for initial random exploration
        
        return curr_action, noise


    def get_individual_observations(
        self, units_operator: "UnitsOperator", start: datetime, end: datetime
    ):
        """
        Retrieves the observations specific to the units_operator. 
        For each unit, computes min and maximum volume that could be dispatch and marginal costs.
        For each technology, sum the volumes and compute the average marginal cost.

        Args
        ----
            units_operator (UnitsOperator): The operator that bids on the market.
            start (datetime.datetime): Start time for the observation period.
            end (datetime.datetime): End time for the observation period

        Returns
        -------
        individual_observations (np.array): min, max capacity and avg marginal cost by technology (scaled)

        Notes
        -----
            The min and max capacities are scaled by self.technology_max_power.
            The avg marginal costs are scaled by self.max_bid_price.
        """

        # --- Current volume & marginal cost ---
        min_volume = {}
        max_volume = {}
        avg_cost = {}

        #iteratively computes the total dispatch volume and volume-weighted marginal cost
        for unit in units_operator.units.values():
            min_mw, max_mw = unit.calculate_min_max_power(start, end)
            cost = unit.calculate_marginal_cost(start, max_mw)
            min_volume[unit.technology] = min_volume.get(unit.technology, 0) + min_mw
            max_volume[unit.technology] = max_volume.get(unit.technology, 0) + max_mw
            avg_cost[unit.technology] = avg_cost.get(unit.technology, 0) + cost * max_mw
        
        #creates a list of scaled volumes and average marginal costs for each technology (alphabetically sorted)
        scaled_min =  [min_volume[tec] / self.technology_max_power[tec] if tec in min_volume else 0 for tec in self.technology_type]
        scaled_max =  [max_volume[tec] / self.technology_max_power[tec] if tec in max_volume else 0 for tec in self.technology_type]
        scaled_cost = [cost / (self.technology_max_power[tec] * self.max_bid_price) if tec in avg_cost else self.max_bid_price for tec in self.technology_type]

        individual_observations = np.array(
            [*scaled_min, *scaled_max, *scaled_cost]
        )

        return individual_observations


    def calculate_reward(
        self,
        units_operator: "UnitsOperator",
        market_config: MarketConfig,
        orderbook: Orderbook,
    ):
        """
        Calculates the reward for the unit based on profits, costs, and opportunity costs from market transactions.

        Args
        ----
            units_operator (UnitsOperator): The operator for which to calculate the reward.
            market_config (MarketConfig): The configuration of the market.
            orderbook (Orderbook): Orderbook containing executed bids and details.

        Notes
        -----
        The reward is computed by multiplying the following:
        **Profit**: Income from accepted bids minus marginal and start-up costs.
        **Scaling**: A scaling factor to normalize the reward to the range [-1,1]

        The reward is scaled and stored along with other outputs in the data to support learning.
        """
        # Function is called after the market is cleared, and we get the market feedback,
        # allowing us to calculate profit based on the realized transactions.
        product_type = market_config.product_type
        start = orderbook[0]["start_time"]
        end = orderbook[0]["end_time"]

        # Depending on how the unit calculates marginal costs, retrieve cost values.
    
        market_clearing_price = orderbook[0]["accepted_price"]
        duration = (end - start) / timedelta(hours=1)

        income = 0.0
        operational_cost = 0.0

        accepted_volume_total = 0
        offered_volume_total = 0

        # Iterate over all orders in the orderbook to calculate order-specific profit.
        for order in orderbook:
            unit_id = order["unit_id"]
            unit = units_operator.units[unit_id]

            accepted_volume = order.get("accepted_volume", 0)
            accepted_volume_total += accepted_volume
            offered_volume_total += order["volume"]

            # Calculate profit as income minus operational cost for this event.
            order_income = market_clearing_price * accepted_volume * duration
            marginal_cost = marginal_cost = unit.calculate_marginal_cost(
                start, unit.outputs[product_type].at[start])
            order_cost = marginal_cost * accepted_volume * duration

            # Consideration of start-up costs, divided evenly between upward and downward regulation events.
            if (
                unit.outputs[product_type].at[start] != 0
                and unit.outputs[product_type].at[start - unit.index.freq] == 0
            ):
                operational_cost += unit.hot_start_cost / 2
            elif (
                unit.outputs[product_type].at[start] == 0
                and unit.outputs[product_type].at[start - unit.index.freq] != 0
            ):
                operational_cost += unit.hot_start_cost / 2

            # Accumulate income and operational cost for all orders.
            income += order_income
            operational_cost += order_cost

        profit = income - operational_cost
        # scaling factor to normalize the reward to the range [-1,1]
        scaling = 1 / (self.max_bid_price * sum(self.technology_max_power.items()))
        reward = scaling * profit

        # Store results in unit outputs, which are later written to the database by the unit operator.
        # `end_excl` marks the last product's start time by subtracting one frequency interval.
        end_excl = end - unit.index.freq 
        units_operator.outputs["profit"].loc[start:end_excl] += profit
        units_operator.outputs["reward"].loc[start:end_excl] = reward
        #units_operator.outputs["regret"].loc[start:end_excl] = regret_scale * opportunity_cost
        units_operator.outputs["total_costs"].loc[start:end_excl] = operational_cost
        units_operator.outputs["rl_rewards"].append(reward)

